{"version":3,"sources":["components/Viewport.js","components/Brush.js","components/GUIController.js","modules/Voxels.js","images/flourish-cc-by-nc-sa.png","components/VoxelManager.js","components/App.js","index.js"],"names":["Viewport","props","canvasRef","React","createRef","this","onCanvasCreation","className","ref","Component","Brush","handleBrushClick","e","name","setState","activeBrush","onBrushChange","state","Fragment","Menu","Item","active","onClick","GUIController","updateMobileState","isMobile","window","innerWidth","addEventListener","removeEventListener","Sidebar","Pushable","as","Segment","inverted","direction","visible","width","Grid","celled","Row","Column","vertical","fluid","style","padding","createDesktopViewport","height","innerHeight","border","borderRadius","createMobileGUI","createDesktopGUI","VoxelWorld","options","cellSize","tileSize","tileTextureWidth","tileTextureHeight","cellSliceSize","cells","x","y","z","voxelX","THREE","euclideanModulo","cellX","Math","floor","cellY","cellZ","cellId","computeCellId","cell","Uint8Array","v","addCell","getCellForVoxel","addCellForVoxel","voxelOffset","computeVoxelOffset","positions","normals","uvs","indices","startX","startY","startZ","voxelY","voxelZ","voxel","getVoxel","uvVoxel","faces","dir","corners","uvRow","ndx","length","pos","uv","push","start","end","dx","dy","dz","lenSq","len","sqrt","t","ix","iy","iz","stepX","stepY","stepZ","txDelta","abs","tyDelta","tzDelta","xDist","yDist","zDist","txMax","Infinity","tyMax","tzMax","steppedIndex","position","normal","brushOptions","add","remove","paint","currentBrush","setCurrentBrush","brushName","brush","Voxels","canvas","renderer","camera","set","controls","OrbitControls","target","update","scene","background","texture","load","render","addLight","light","magFilter","minFilter","world","material","map","side","alphaTest","transparent","cellIdToMesh","updateCellGeometry","mesh","geometry","generateGeometryDataForCell","setAttribute","Float32Array","setIndex","computeBoundingSphere","neighborOffsets","updateVoxelGeometry","updatedCellIds","offset","ox","oy","oz","createSineWave","sin","PI","setVoxel","randInt","min","max","random","renderRequested","undefined","domElement","clientWidth","clientHeight","needResize","setSize","resizeRendererToDisplaySize","aspect","updateProjectionMatrix","requestRenderIfNotRequested","requestAnimationFrame","placeVoxel","event","rect","getBoundingClientRect","clientX","left","clientY","top","getCanvasRelativePosition","setFromMatrixPosition","matrixWorld","unproject","intersection","intersectRay","voxelId","mouse","recordMovement","moveX","moveY","placeVoxelIfNoMovement","preventDefault","recordStartPosition","passive","VoxelManager","current","createVoxelWorld","App","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.bda772f8.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./Viewport.css\";\n\n/**\n * Handles the 3D viewport and surrounding GUI for the application.\n * @property {Ref} canvasRef - Reference to the canvas\n *\n * @extends React.Component\n */\nclass Viewport extends React.Component {\n  constructor(props) {\n    super(props);\n\n    // Reference to canvas element\n    this.canvasRef = React.createRef();\n  }\n\n  componentDidMount() {\n    // Canvas is ready to be drawn on\n    this.props.onCanvasCreation(this.canvasRef);\n  }\n\n  render() {\n    return <canvas className=\"viewportCanvas\" ref={this.canvasRef} />;\n  }\n}\n\nexport default Viewport;\n","import React from \"react\";\nimport { Menu } from \"semantic-ui-react\";\n\n/**\n * Allows user to switch between basic brush options such as add, remove, and paint.\n * @extends React.Component\n */\nclass Brush extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      activeBrush: \"add\",\n    };\n  }\n\n  componentDidMount() {\n    // Send the initial brush name to parent component\n    this.props.onBrushChange(this.state.activeBrush);\n  }\n\n  /**\n   * Handler for each brush option. Upon click, updates the currently\n   * selected brush.\n   * @param {Event} e - React's original SyntheticEvent\n   * @param {data} props - Prop data from the Menu.Item\n   */\n  handleBrushClick = (e, { name }) => {\n    // Update state with current brush.\n    this.setState({ activeBrush: name });\n\n    // Send active brush name to parent component\n    this.props.onBrushChange(name);\n  };\n\n  render() {\n    const { activeBrush } = this.state;\n\n    return (\n      <React.Fragment>\n        <Menu.Item\n          name=\"add\"\n          active={activeBrush === \"add\"}\n          onClick={this.handleBrushClick}\n        >\n          Add\n        </Menu.Item>\n        <Menu.Item\n          name=\"remove\"\n          active={activeBrush === \"remove\"}\n          onClick={this.handleBrushClick}\n        >\n          Remove\n        </Menu.Item>\n        <Menu.Item\n          name=\"paint\"\n          active={activeBrush === \"paint\"}\n          onClick={this.handleBrushClick}\n        >\n          Paint\n        </Menu.Item>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default Brush;\n","import React from \"react\";\nimport Viewport from \"./Viewport\";\nimport Brush from \"./Brush\";\nimport \"./GUIController.css\";\nimport { Grid, Sidebar, Segment, Menu } from \"semantic-ui-react\";\n\n/**\n * Handles switching between both desktop and mobile versions of the\n * UI. Whenever one of its chidlren updates, it will pass that data\n * up to its parent component.\n * @extends React.Component\n */\nclass GUIController extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      isMobile: false,\n    };\n  }\n\n  /**\n   * Handler for screen resize events that updates whether or not the application\n   * should currently be using the mobile or desktop GUI.\n   */\n  updateMobileState = () => {\n    // If width below 768, use mobile GUI\n    const isMobile = window.innerWidth < 768;\n    this.setState({ isMobile });\n  };\n\n  componentDidMount() {\n    // Perform initial check for mobile device\n    this.updateMobileState();\n    window.addEventListener(\"resize\", this.updateMobileState);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener(\"resize\", this.updateMobileState);\n  }\n\n  /**\n   * Creates the JSX for the desktop version of the viewport.\n   * @returns {JSX}\n   */\n  createDesktopViewport() {\n    return (\n      <Sidebar.Pushable as={Segment}>\n        <Sidebar as={Menu} inverted direction=\"top\" visible width=\"very thin\">\n          <Menu.Item as=\"a\">Undo</Menu.Item>\n          <Menu.Item as=\"a\">Redo</Menu.Item>\n        </Sidebar>\n        <Viewport onCanvasCreation={this.props.onCanvasCreation} />\n      </Sidebar.Pushable>\n    );\n  }\n\n  /**\n   * Create the desktop version of the UI.\n   * @returns {JSX}\n   */\n  createDesktopGUI() {\n    return (\n      <Grid celled className={\"desktopGrid\"}>\n        <Grid.Row>\n          <Grid.Column width={3}>\n            <Menu vertical fluid inverted>\n              <Brush onBrushChange={this.props.onBrushChange} />\n            </Menu>\n          </Grid.Column>\n\n          <Grid.Column width={11} style={{ padding: \"0\" }}>\n            {this.createDesktopViewport()}\n          </Grid.Column>\n\n          <Grid.Column width={2}>\n            <h1>Right Panel</h1>\n          </Grid.Column>\n        </Grid.Row>\n      </Grid>\n    );\n  }\n\n  /**\n   * Create the mobile version of the UI.\n   * @returns {JSX}\n   */\n  createMobileGUI() {\n    return (\n      <div style={{ height: window.innerHeight }}>\n        <Sidebar.Pushable\n          as={Segment}\n          style={{ border: \"none\", borderRadius: \"0\" }}\n        >\n          <Sidebar as={Menu} inverted direction=\"top\" visible width=\"very thin\">\n            <Menu.Item as=\"a\">Color Palette</Menu.Item>\n            <Menu.Item as=\"a\">Edit</Menu.Item>\n            <Menu.Item as=\"a\">Camera</Menu.Item>\n            <Menu.Item as=\"a\">Project</Menu.Item>\n          </Sidebar>\n\n          <Sidebar as={Menu} inverted direction=\"bottom\" visible width=\"thin\">\n            <Brush onBrushChange={this.props.onBrushChange} />\n          </Sidebar>\n\n          <Viewport onCanvasCreation={this.props.onCanvasCreation} />\n        </Sidebar.Pushable>\n      </div>\n    );\n  }\n\n  render() {\n    // TODO: Change from arbitrary number\n    return this.state.isMobile\n      ? this.createMobileGUI()\n      : this.createDesktopGUI();\n  }\n}\n\nexport default GUIController;\n","import * as THREE from \"three\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport textureAtlas from \"../images/flourish-cc-by-nc-sa.png\";\n\n/**\n * Manages voxel data.\n * At the top level, a single VoxelWorld consists of cells. Each cell is a 'chunk' of the world\n * that consists of voxels (i.e. cubes). In order to optimize render times, we merge the geometry\n * of all the voxels within a single cell and make a single render call (as opposed to rendering\n * each individual voxel). In addition, a single cell is essentially a 3D grid that voxels are\n * placed in. Each cell has a length, width, and height dictated by the cellSize variable. This could\n * be set to anything but is perhaps best capped at 128 or 256 (256^3 is 16,777,216 voxels!).\n *\n * @property {number} cellSize      - The length, width, and height of a single cell (or chunk) within the world\n * @property {number} cellSliceSize - The area of a single slice of each cell (cellSize^2)\n * @property {Object} cell          - Object consisting of an array for each cell\n */\nclass VoxelWorld {\n  /**\n   * Creates a VoxelWorld object with the given options\n   * @param {Object} options - Options to spawn the world with\n   * @param {number} options.cellSize - The length, width, and height of each cell\n   * @param {number} options.tileSize - The size of each tile from a texture atlas\n   * @param {number} options.tileTextureWidth - The width of the texture atlas\n   * @param {number} options.tileTextureHeight - The height of the texture atlas\n   */\n  constructor(options) {\n    this.cellSize = options.cellSize;\n    this.tileSize = options.tileSize;\n    this.tileTextureWidth = options.tileTextureWidth;\n    this.tileTextureHeight = options.tileTextureHeight;\n    const { cellSize } = this;\n    this.cellSliceSize = cellSize * cellSize;\n    this.cells = {};\n  }\n\n  /**\n   * Returns the offset, or index, to the voxel within the cell array\n   * at the given x, y, and z coordinates.\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   * @returns {number} Index to the voxel within the cell array\n   */\n  computeVoxelOffset(x, y, z) {\n    const { cellSize, cellSliceSize } = this;\n\n    // Note, the \"| 0\" actually TRUNCATES the value! Not quite the same as flooring\n    // https://stackoverflow.com/questions/7487977/using-bitwise-or-0-to-floor-a-number\n    // Also, euclideanModulo(n, m) is the equivalent of (( n % m ) + m ) % m\n    const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;\n    const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;\n    const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;\n\n    // Return index voxel is located at\n    return voxelY * cellSliceSize + voxelZ * cellSize + voxelX;\n  }\n\n  /**\n   * Computes the id of the cell stored as a key in this.cells based\n   * on the given x, y, and z coordinates of a voxel.\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   * @returns {string} The id of the cell in the form of \"(x,y,z)\"\n   */\n  computeCellId(x, y, z) {\n    const { cellSize } = this;\n    const cellX = Math.floor(x / cellSize);\n    const cellY = Math.floor(y / cellSize);\n    const cellZ = Math.floor(z / cellSize);\n    return `${cellX},${cellY},${cellZ}`;\n  }\n\n  /**\n   * Adds a new cell for a voxel at the given x, y, and z coordinates if a\n   * cell doesn't already exist to accomodate it.\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   * @returns {Uint8Array} Array of voxels for the cell\n   */\n  addCellForVoxel(x, y, z) {\n    // Get the id of the cell corresponding to the x, y, and z coordinate\n    const cellId = this.computeCellId(x, y, z);\n\n    // Get the array of voxels associated with the cellId\n    let cell = this.cells[cellId];\n\n    // If cell doesn't exist, add it\n    if (!cell) {\n      const { cellSize } = this;\n      cell = new Uint8Array(cellSize * cellSize * cellSize);\n      this.cells[cellId] = cell;\n    }\n\n    // Return the cell\n    return cell;\n  }\n\n  /**\n   * Finds the corresponding voxel array for the cell for the given voxel coordinates.\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   * @returns {Uint8Array} Array of voxels.\n   */\n  getCellForVoxel(x, y, z) {\n    return this.cells[this.computeCellId(x, y, z)];\n  }\n\n  /**\n   * Sets voxel at given coordinates.\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   * @param {number} v - The type of voxel to add\n   * @param {boolean} addCell - If true, a new cell will be created to accomodate the voxel if needed\n   */\n  setVoxel(x, y, z, v, addCell = true) {\n    // Get the array of voxels corresponding to the x, y, and z coordinates\n    let cell = this.getCellForVoxel(x, y, z);\n\n    // No cell was found\n    if (!cell) {\n      // If addCell is false, return\n      if (!addCell) {\n        return;\n      }\n      // Otherwise, create a new cell for the voxel\n      cell = this.addCellForVoxel(x, y, z);\n    }\n\n    // Find the index to add the new voxel within the found cell\n    const voxelOffset = this.computeVoxelOffset(x, y, z);\n\n    // Set the new voxel\n    cell[voxelOffset] = v;\n  }\n\n  /**\n   * Gets the corresponding voxel at the given coordinates.\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   * @returns {number} Number representing the type of voxel\n   */\n  getVoxel(x, y, z) {\n    // Find the cell that has the voxel at the given coordinates\n    const cell = this.getCellForVoxel(x, y, z);\n\n    // No such cell exists! Default by returning 0\n    if (!cell) {\n      return 0;\n    }\n\n    // Find the index of the voxel within the cell\n    const voxelOffset = this.computeVoxelOffset(x, y, z);\n\n    // Return the voxel that was found\n    return cell[voxelOffset];\n  }\n\n  /**\n   * Generates geometry data for a cell at the given coordinate. Similar to voxels, each cell\n   * is a part of a 3D grid as well.\n   * @example\n   * generateGeometryDataForCell(0, 0, 0);  // Cell created at (0, 0, 0) coordinate\n   * generateGeometryDataForCell(0, 1, 0);  // Cell created above the last one at (0, 1, 0)\n   *\n   * @param {number} cellX\n   * @param {number} cellY\n   * @param {number} cellZ\n   */\n  generateGeometryDataForCell(cellX, cellY, cellZ) {\n    const { cellSize, tileSize, tileTextureWidth, tileTextureHeight } = this;\n\n    // Used for generating the geometry of the final mesh formed by the voxels\n    const positions = [];\n    const normals = [];\n    const uvs = [];\n    const indices = [];\n\n    // Calculate origin point of the cell i.e. (0, 0, 0)\n    const startX = cellX * cellSize;\n    const startY = cellY * cellSize;\n    const startZ = cellZ * cellSize;\n\n    // Iterate over y coords\n    for (let y = 0; y < cellSize; ++y) {\n      const voxelY = startY + y;\n      // Iterate over z coords\n      for (let z = 0; z < cellSize; ++z) {\n        const voxelZ = startZ + z;\n        // Iterate over x coords\n        for (let x = 0; x < cellSize; ++x) {\n          const voxelX = startX + x;\n\n          // Get voxel at current x, y, and z coords\n          const voxel = this.getVoxel(voxelX, voxelY, voxelZ);\n\n          // Check if voxel exists (by default, a voxel 0 is empty)\n          if (voxel) {\n            // voxel 0 is sky so for UVs we start at 0\n            const uvVoxel = voxel - 1;\n\n            // There is a voxel here but do we need faces for it?\n            for (const { dir, corners, uvRow } of VoxelWorld.faces) {\n              // The neighboring voxel to the face of our voxel\n              const neighbor = this.getVoxel(\n                voxelX + dir[0],\n                voxelY + dir[1],\n                voxelZ + dir[2]\n              );\n\n              // neighbor voxel is empty (0) in this direction so we need a face\n              if (!neighbor) {\n                // Used to define the indices\n                const ndx = positions.length / 3;\n\n                // Add vertices for the face of the voxel and normals too\n                for (const { pos, uv } of corners) {\n                  positions.push(pos[0] + x, pos[1] + y, pos[2] + z);\n                  normals.push(...dir);\n\n                  // Calculates where to grab texture from the texture atlas\n                  // uvVoxel corresponds to the column and uvRow the row to get the texture\n                  uvs.push(\n                    ((uvVoxel + uv[0]) * tileSize) / tileTextureWidth,\n                    1 - ((uvRow + 1 - uv[1]) * tileSize) / tileTextureHeight\n                  );\n                }\n\n                // Add indices used to draw the face\n                indices.push(ndx, ndx + 1, ndx + 2, ndx + 2, ndx + 1, ndx + 3);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Return object consisting of geometry data for the voxel model\n    return {\n      positions,\n      normals,\n      uvs,\n      indices,\n    };\n  }\n\n  /**\n   * Algorithm for raycasting specialized for use with voxels. Used to check if the\n   * user clicked a voxel in the scene and returns information related to it such as\n   * the coordinates of the successful hit.\n   * The code itself is based upon this paper: http://www.cse.chalmers.se/edu/year/2010/course/TDA361/grid.pdf\n   * @param {*} start\n   * @param {*} end\n   * @returns {Object} HitResults or null if nothing was hit\n   * @returns {Array.<number>} HitResults.position Coordinates of the hit\n   * @returns {Array.<number} HitResults.normal Normal of the hit\n   * @returns {number} HitResults.voxel The type of voxel hit\n   */\n  intersectRay(start, end) {\n    // Get the direction that ray is cast\n    let dx = end.x - start.x;\n    let dy = end.y - start.y;\n    let dz = end.z - start.z;\n\n    // Find the magnitude of the above direction\n    const lenSq = dx * dx + dy * dy + dz * dz;\n    const len = Math.sqrt(lenSq);\n\n    // Change to unit vector so we only have the direction of the ray cast\n    dx /= len;\n    dy /= len;\n    dz /= len;\n\n    // t is a scalar that we use to 'stretch' the ray into the scene to test for intersections\n    let t = 0.0;\n    let ix = Math.floor(start.x);\n    let iy = Math.floor(start.y);\n    let iz = Math.floor(start.z);\n\n    // Dictates how we 'step' from voxel to voxel\n    const stepX = dx > 0 ? 1 : -1;\n    const stepY = dy > 0 ? 1 : -1;\n    const stepZ = dz > 0 ? 1 : -1;\n\n    // The amount of change required to advance one whole voxel\n    const txDelta = Math.abs(1 / dx);\n    const tyDelta = Math.abs(1 / dy);\n    const tzDelta = Math.abs(1 / dz);\n\n    const xDist = stepX > 0 ? ix + 1 - start.x : start.x - ix;\n    const yDist = stepY > 0 ? iy + 1 - start.y : start.y - iy;\n    const zDist = stepZ > 0 ? iz + 1 - start.z : start.z - iz;\n\n    // location of nearest voxel boundary, in units of t\n    let txMax = txDelta < Infinity ? txDelta * xDist : Infinity;\n    let tyMax = tyDelta < Infinity ? tyDelta * yDist : Infinity;\n    let tzMax = tzDelta < Infinity ? tzDelta * zDist : Infinity;\n\n    // Represents the direction we last stepped in. Either x, y, or z\n    let steppedIndex = -1;\n\n    // main loop along raycast vector\n    while (t <= len) {\n      // Get the voxel at the ix, iy, and iz coordinate\n      const voxel = this.getVoxel(ix, iy, iz);\n\n      // Found a non-empty voxel! Return hit information\n      if (voxel) {\n        return {\n          position: [start.x + t * dx, start.y + t * dy, start.z + t * dz],\n          normal: [\n            steppedIndex === 0 ? -stepX : 0,\n            steppedIndex === 1 ? -stepY : 0,\n            steppedIndex === 2 ? -stepZ : 0,\n          ],\n          voxel,\n        };\n      }\n\n      // advance t to next nearest voxel boundary\n      // This is the core if-statement from the research paper\n      if (txMax < tyMax) {\n        if (txMax < tzMax) {\n          ix += stepX;\n          t = txMax;\n          txMax += txDelta;\n          steppedIndex = 0;\n        } else {\n          iz += stepZ;\n          t = tzMax;\n          tzMax += tzDelta;\n          steppedIndex = 2;\n        }\n      } else {\n        if (tyMax < tzMax) {\n          iy += stepY;\n          t = tyMax;\n          tyMax += tyDelta;\n          steppedIndex = 1;\n        } else {\n          iz += stepZ;\n          t = tzMax;\n          tzMax += tzDelta;\n          steppedIndex = 2;\n        }\n      }\n    }\n\n    // Nothing was found, return null\n    return null;\n  }\n}\n\n/**\n * Array of objects that represent each face of a single voxel.\n * uvRow is the row of the texture atlas to grab an image from\n * dir is the direction of the face\n * corners consist of vertices and uv coordinates for the texture\n */\nVoxelWorld.faces = [\n  {\n    // left\n    uvRow: 0,\n    dir: [-1, 0, 0],\n    corners: [\n      { pos: [0, 1, 0], uv: [0, 1] },\n      { pos: [0, 0, 0], uv: [0, 0] },\n      { pos: [0, 1, 1], uv: [1, 1] },\n      { pos: [0, 0, 1], uv: [1, 0] },\n    ],\n  },\n  {\n    // right\n    uvRow: 0,\n    dir: [1, 0, 0],\n    corners: [\n      { pos: [1, 1, 1], uv: [0, 1] },\n      { pos: [1, 0, 1], uv: [0, 0] },\n      { pos: [1, 1, 0], uv: [1, 1] },\n      { pos: [1, 0, 0], uv: [1, 0] },\n    ],\n  },\n  {\n    // bottom\n    uvRow: 1,\n    dir: [0, -1, 0],\n    corners: [\n      { pos: [1, 0, 1], uv: [1, 0] },\n      { pos: [0, 0, 1], uv: [0, 0] },\n      { pos: [1, 0, 0], uv: [1, 1] },\n      { pos: [0, 0, 0], uv: [0, 1] },\n    ],\n  },\n  {\n    // top\n    uvRow: 2,\n    dir: [0, 1, 0],\n    corners: [\n      { pos: [0, 1, 1], uv: [1, 1] },\n      { pos: [1, 1, 1], uv: [0, 1] },\n      { pos: [0, 1, 0], uv: [1, 0] },\n      { pos: [1, 1, 0], uv: [0, 0] },\n    ],\n  },\n  {\n    // back\n    uvRow: 0,\n    dir: [0, 0, -1],\n    corners: [\n      { pos: [1, 0, 0], uv: [0, 0] },\n      { pos: [0, 0, 0], uv: [1, 0] },\n      { pos: [1, 1, 0], uv: [0, 1] },\n      { pos: [0, 1, 0], uv: [1, 1] },\n    ],\n  },\n  {\n    // front\n    uvRow: 0,\n    dir: [0, 0, 1],\n    corners: [\n      { pos: [0, 0, 1], uv: [0, 0] },\n      { pos: [1, 0, 1], uv: [1, 0] },\n      { pos: [0, 1, 1], uv: [0, 1] },\n      { pos: [1, 1, 1], uv: [1, 1] },\n    ],\n  },\n];\n\n// TODO: Refactor code to decouple main render loop.\n// Taking a lazy approach so as to get the Brush working first\n//\n// Enum of brush options\nconst brushOptions = {\n  add: \"add\",\n  remove: \"remove\",\n  paint: \"paint\",\n};\n\n// Set add brush as default\nlet currentBrush = brushOptions.add;\n\n/**\n * Sets the current brush to one of the available brush options.\n * @param {string} brushName\n */\nfunction setCurrentBrush(brushName) {\n  // Get the brush to set\n  const brush = brushOptions[brushName];\n\n  // If that brush exists, set it as current\n  if (brush) {\n    currentBrush = brush;\n  }\n}\n\n/**\n * Helper function used to create the VoxelWorld.\n */\nfunction Voxels(canvas) {\n  const renderer = new THREE.WebGLRenderer({ canvas });\n\n  // Length, width, and height of each cell in the VoxelWorld\n  const cellSize = 32;\n\n  // Create the camera\n  const fov = 75;\n  const aspect = 2; // the canvas default\n  const near = 0.1;\n  const far = 1000;\n  const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n  camera.position.set(-cellSize * 0.3, cellSize * 0.8, -cellSize * 0.3);\n\n  // Create the orbit controls\n  const controls = new OrbitControls(camera, canvas);\n  controls.target.set(cellSize / 2, cellSize / 3, cellSize / 2);\n  controls.update();\n\n  // Create the scene\n  const scene = new THREE.Scene();\n  scene.background = new THREE.Color(\"lightblue\");\n\n  // Load texture atlas\n  const tileSize = 16;\n  const tileTextureWidth = 256;\n  const tileTextureHeight = 64;\n  const loader = new THREE.TextureLoader();\n  const texture = loader.load(textureAtlas, render);\n  texture.magFilter = THREE.NearestFilter;\n  texture.minFilter = THREE.NearestFilter;\n\n  /**\n   * Adds a directional light to the scene at the given x, y, and z position.\n   * Remember, the default position of the directional light's target is (0, 0, 0).\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   */\n  function addLight(x, y, z) {\n    const color = 0xffffff;\n    const intensity = 1;\n    const light = new THREE.DirectionalLight(color, intensity);\n    light.position.set(x, y, z);\n    scene.add(light);\n  }\n\n  // Add two directional lights to the scene\n  addLight(-1, 2, 4);\n  addLight(1, -1, -2);\n\n  // Create a new VoxelWorld that will manage our voxels\n  const world = new VoxelWorld({\n    cellSize,\n    tileSize,\n    tileTextureWidth,\n    tileTextureHeight,\n  });\n\n  // Create material for the voxel model\n  const material = new THREE.MeshLambertMaterial({\n    map: texture,\n    side: THREE.DoubleSide,\n    alphaTest: 0.1,\n    transparent: true,\n  });\n\n  // Used in the updateCellGeometry() function\n  // Tracks the meshes for each cell\n  // TODO: Not good having a global variable like this! Find a better spot for it\n  const cellIdToMesh = {};\n\n  /**\n   *\n   * @param {*} x\n   * @param {*} y\n   * @param {*} z\n   */\n  function updateCellGeometry(x, y, z) {\n    // Find the cell corresponding to the voxel at the x, y, and z coordinates\n    const cellX = Math.floor(x / cellSize);\n    const cellY = Math.floor(y / cellSize);\n    const cellZ = Math.floor(z / cellSize);\n    const cellId = world.computeCellId(x, y, z);\n\n    // Get the mesh corresponding to the given cellId\n    let mesh = cellIdToMesh[cellId];\n    // Get the geometry of the mesh. If no mesh exists, create new geometry\n    const geometry = mesh ? mesh.geometry : new THREE.BufferGeometry();\n\n    // Retrieve data for making the geometry for a given cell\n    const {\n      positions,\n      normals,\n      uvs,\n      indices,\n    } = world.generateGeometryDataForCell(cellX, cellY, cellZ);\n\n    // Set position (vertex) data of cell\n    const positionNumComponents = 3;\n    geometry.setAttribute(\n      \"position\",\n      new THREE.BufferAttribute(\n        new Float32Array(positions),\n        positionNumComponents\n      )\n    );\n\n    // Set normal data for cell\n    const normalNumComponents = 3;\n    geometry.setAttribute(\n      \"normal\",\n      new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents)\n    );\n\n    // Set uv data for cell\n    const uvNumComponents = 2;\n    geometry.setAttribute(\n      \"uv\",\n      new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents)\n    );\n\n    // Set index data for cell\n    geometry.setIndex(indices);\n\n    // Comput bounding sphere of the geometry\n    geometry.computeBoundingSphere();\n\n    // If the mesh has not yet been created, create it!\n    if (!mesh) {\n      mesh = new THREE.Mesh(geometry, material);\n      mesh.name = cellId;\n      cellIdToMesh[cellId] = mesh;\n      scene.add(mesh);\n      mesh.position.set(cellX * cellSize, cellY * cellSize, cellZ * cellSize);\n    }\n  }\n\n  // Used in updateVoxelGeometry() function\n  // TODO: Find a better spot for this variable!\n  const neighborOffsets = [\n    [0, 0, 0], // self\n    [-1, 0, 0], // left\n    [1, 0, 0], // right\n    [0, -1, 0], // down\n    [0, 1, 0], // up\n    [0, 0, -1], // back\n    [0, 0, 1], // front\n  ];\n\n  /**\n   * Updates the voxel of a cell at the given x, y, and z coordinates. Also,\n   * updates any cells that the voxel is adjacent to.\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   */\n  function updateVoxelGeometry(x, y, z) {\n    const updatedCellIds = {};\n\n    // Check the cell and all surrounding cells when updating voxel geometry\n    for (const offset of neighborOffsets) {\n      // Get the coordinates of the current cell to update\n      const ox = x + offset[0];\n      const oy = y + offset[1];\n      const oz = z + offset[2];\n\n      // Get the id of the cell we wish to update\n      const cellId = world.computeCellId(ox, oy, oz);\n\n      // If cell yet not updated, update it!\n      if (!updatedCellIds[cellId]) {\n        updatedCellIds[cellId] = true;\n\n        // Update the cell's geometry\n        updateCellGeometry(ox, oy, oz);\n      }\n    }\n  }\n\n  /**\n   * Has the cell at the given coordinates form a sine wave out of its voxels.\n   * @param {number} cellX\n   * @param {number} cellY\n   * @param {number} cellZ\n   * @param {number} v - The type of voxel to spawn. 0 for random\n   */\n  function createSineWave(cellX, cellY, cellZ, v = 0) {\n    const startX = cellX * cellSize;\n    const startY = cellY * cellSize;\n    const startZ = cellZ * cellSize;\n\n    // Create a sine wave with our voxels\n    for (let y = 0; y < cellSize; ++y) {\n      for (let z = 0; z < cellSize; ++z) {\n        for (let x = 0; x < cellSize; ++x) {\n          // Calculate the maximum height at the x and z position for a voxel to be placed\n          const height =\n            (Math.sin((x / cellSize) * Math.PI * 2) +\n              Math.sin((z / cellSize) * Math.PI * 3)) *\n              (cellSize / 6) +\n            cellSize / 2;\n\n          // Set voxel if y is below the height\n          if (y < height) {\n            // Set voxel to random texture\n            world.setVoxel(\n              startX + x,\n              startY + y,\n              startZ + z,\n              v ? v : randInt(1, 17)\n            );\n          }\n        }\n      }\n    }\n  }\n\n  // Generate various sine waves\n  createSineWave(0, 0, 0); // Center\n  createSineWave(1, 0, 0, 2); // Right\n  createSineWave(-1, 0, 0, 3); // Left\n  createSineWave(0, 0, -1, 4); // Forward\n  createSineWave(0, 0, 1, 5); // Backward\n\n  // Update geometry so that it get rendered\n  // Remember, cells adjacent to the voxel coordinate will also update\n  updateVoxelGeometry(0, 0, 0);\n  updateVoxelGeometry(cellSize - 1, 0, cellSize - 1);\n\n  /**\n   * Helper function to return a random integer between the min and max value\n   * in a range of [min, max).\n   * @param {number} min\n   * @param {number} max\n   * @returns\n   */\n  function randInt(min, max) {\n    return Math.floor(Math.random() * (max - min) + min);\n  }\n\n  /**\n   * Checks if the renderer needs to resize to account for changes in screen\n   * width or height.\n   * @param {WebGLRenderer} renderer\n   * @returns {boolean} True if the renderer resized. False otherwise.\n   */\n  function resizeRendererToDisplaySize(renderer) {\n    const canvas = renderer.domElement;\n\n    const width = canvas.clientWidth;\n    const height = canvas.clientHeight;\n\n    const needResize = canvas.width !== width || canvas.height !== height;\n    if (needResize) {\n      renderer.setSize(width, height, false);\n    }\n    return needResize;\n  }\n\n  // Used with requestRenderIfNotRequested() function\n  // TODO: Find a better place for this variable!\n  let renderRequested = false;\n\n  /**\n   * Main render loop.\n   */\n  function render() {\n    renderRequested = undefined;\n\n    if (resizeRendererToDisplaySize(renderer)) {\n      camera.aspect = canvas.clientWidth / canvas.clientHeight;\n      camera.updateProjectionMatrix();\n    }\n\n    controls.update();\n    renderer.render(scene, camera);\n  }\n  render();\n\n  /**\n   * Used to make a render update request only if one hasn't been made already.\n   */\n  function requestRenderIfNotRequested() {\n    if (!renderRequested) {\n      renderRequested = true;\n      requestAnimationFrame(render);\n    }\n  }\n\n  // The current voxel to add when clicking. 0 represent nothing so it effectively removes voxels.\n  // TODO: This value needs to be tied to react!\n  let currentVoxel = 1; // add pumpkins\n\n  /**\n   * Finds the x and y coordinate of a mouse click relative to the canvas.\n   * @param {Event} event\n   * @returns {Object} Object with x and y coordinates of click relative to canvas\n   */\n  function getCanvasRelativePosition(event) {\n    const rect = canvas.getBoundingClientRect();\n\n    // Calculate the x and y of click relative to the canvas\n    return {\n      x: ((event.clientX - rect.left) * canvas.width) / rect.width,\n      y: ((event.clientY - rect.top) * canvas.height) / rect.height,\n    };\n  }\n\n  /**\n   * Adds, removes, or paints a voxel based on the given brush.\n   * @param {Event} event\n   * @param {brushOptions} brush - The type of brush to paint with\n   */\n  function placeVoxel(event, brush) {\n    // Find position of mouse click relative to canvas\n    const pos = getCanvasRelativePosition(event);\n    const x = (pos.x / canvas.width) * 2 - 1;\n    const y = (pos.y / canvas.height) * -2 + 1; // note we flip Y\n\n    // Get the starting and ending vectors for our raycast\n    const start = new THREE.Vector3();\n    const end = new THREE.Vector3();\n    start.setFromMatrixPosition(camera.matrixWorld);\n    end.set(x, y, 1).unproject(camera);\n\n    // Cast a ray into the scene\n    const intersection = world.intersectRay(start, end);\n\n    // If raycast was successful, place a voxel with the information returned\n    if (intersection) {\n      // Set voxelId depending on brush option. 0 removes voxels\n      const voxelId = brush === brushOptions.remove ? 0 : currentVoxel;\n\n      // the intersection point is on the face. That means\n      // the math imprecision could put us on either side of the face.\n      // so go half a normal into the voxel if removing/painting\n      // or half a normal out if adding\n      const pos = intersection.position.map((v, ndx) => {\n        return (\n          v +\n          intersection.normal[ndx] * (brush === brushOptions.add ? 0.5 : -0.5)\n        );\n      });\n\n      // Set voxel at the pos position with new voxelID\n      world.setVoxel(...pos, voxelId);\n\n      // Update the cell associated with the position of the new voxel\n      updateVoxelGeometry(...pos);\n\n      // Update render frame\n      requestRenderIfNotRequested();\n    }\n  }\n\n  /**\n   * Mouse object representing the position of mouse clicks.\n   */\n  const mouse = {\n    x: 0,\n    y: 0,\n  };\n\n  /**\n   * Reset mouse movement and begin recording.\n   * @param {Event} event\n   */\n  function recordStartPosition(event) {\n    mouse.x = event.clientX;\n    mouse.y = event.clientY;\n    mouse.moveX = 0;\n    mouse.moveY = 0;\n  }\n\n  /**\n   * Callback function used to record how far the mouse has moved since started recording.\n   * @param {Event} event\n   */\n  function recordMovement(event) {\n    mouse.moveX += Math.abs(mouse.x - event.clientX);\n    mouse.moveY += Math.abs(mouse.y - event.clientY);\n  }\n\n  /**\n   * Callback function used to check if the user meant to set a voxel instead\n   * of orbiting the camera.\n   * @param {Event} event\n   */\n  function placeVoxelIfNoMovement(event) {\n    // Mouse hardly moved, user likely intended to place a voxel\n    if (mouse.moveX < 5 && mouse.moveY < 5) {\n      // TODO: Remove global variable currentBrush\n      placeVoxel(event, currentBrush);\n    }\n\n    // Stop recording movement and checks to place voxel\n    window.removeEventListener(\"pointermove\", recordMovement);\n    window.removeEventListener(\"pointerup\", placeVoxelIfNoMovement);\n  }\n\n  // Listen for mouse clicks\n  canvas.addEventListener(\n    \"pointerdown\",\n    (event) => {\n      event.preventDefault();\n      // Record where we first clicked\n      recordStartPosition(event);\n\n      // Record mouse movement\n      window.addEventListener(\"pointermove\", recordMovement);\n\n      // Add voxel upon releasing mouse click if movement is small. Other,\n      // user is orbiting the camera\n      window.addEventListener(\"pointerup\", placeVoxelIfNoMovement);\n    },\n    { passive: false }\n  );\n\n  // Listen for touch events\n  canvas.addEventListener(\n    \"touchstart\",\n    (event) => {\n      // prevent scrolling\n      event.preventDefault();\n    },\n    { passive: false }\n  );\n\n  // Listen for camera orbit events\n  controls.addEventListener(\"change\", requestRenderIfNotRequested);\n\n  // Listen for window resizing events\n  window.addEventListener(\"resize\", requestRenderIfNotRequested);\n}\n\nexport { Voxels, setCurrentBrush };\n","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAABACAYAAAD1Xam+AAAACXBIWXMAAAsTAAALEwEAmpwYAAAGAGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMTktMDYtMTlUMTU6NDc6MDgrMDk6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMTktMDYtMTlUMTU6NDc6MDgrMDk6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDE5LTA2LTE5VDE1OjQ3OjA4KzA5OjAwIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjI2ZTk2MTM4LTNjMDctNDg1NS1iMzJkLWNiODEzYWY0OWEwMCIgeG1wTU06RG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOmI3NjBlMzNkLWM1MDMtMjg0MC1iMDM2LWM5NzNjOTlhMmZmMSIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjg1MWQ5N2FkLTRhOTctNDkyZS05YzcxLWFmYWRkNGY4MmMyMyIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJzUkdCIElFQzYxOTY2LTIuMSI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ODUxZDk3YWQtNGE5Ny00OTJlLTljNzEtYWZhZGQ0ZjgyYzIzIiBzdEV2dDp3aGVuPSIyMDE5LTA2LTE5VDE1OjQ3OjA4KzA5OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoTWFjaW50b3NoKSIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MjZlOTYxMzgtM2MwNy00ODU1LWIzMmQtY2I4MTNhZjQ5YTAwIiBzdEV2dDp3aGVuPSIyMDE5LTA2LTE5VDE1OjQ3OjA4KzA5OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoTWFjaW50b3NoKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6yxlNQAAAMxklEQVR42u1dLa9cVRSdn8APqKhAVDzxRAWipqICgUBUICqeQDQBgXiiAvMUH0lFDUmDIAjEEw2pQDQBA0kFIQhERQUCUYFAVg6zb2ZN1tvd+3zfuTPpbrIy995zzmOYuWvd/XX2rP69vLsG/j6/vX557+b0ytdTY6///Wf14uVn68fPPnwD9x/fWqfGNmvXf/1yuX75/KdmfH9xf31x9tH6zycXE54+Ol8//OzsCuQaxuVc5ss6gNdfu/Ne1fpfL+42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\"","import React from \"react\";\nimport GUIController from \"./GUIController\";\nimport { Voxels, setCurrentBrush } from \"../modules/Voxels\";\n\n/**\n * The main driving component for the application. Sets up the rest of\n * the user interface and directly communicates with the Voxel.js module.\n * @extends React.Component\n */\nclass VoxelManager extends React.Component {\n  /**\n   * Takes the given canvas Ref and renders the voxel world.\n   * @param {Ref} canvasRef\n   */\n  createVoxelWorld(canvasRef) {\n    if (canvasRef) {\n      Voxels(canvasRef.current);\n    }\n  }\n\n  render() {\n    return (\n      <GUIController\n        onCanvasCreation={this.createVoxelWorld}\n        onBrushChange={setCurrentBrush}\n      />\n    );\n  }\n}\n\nexport default VoxelManager;\n","import \"./App.css\";\nimport VoxelManager from \"./VoxelManager\";\n\nconst App = () => {\n  return <VoxelManager />;\n};\n\nexport default App;\n","import \"semantic-ui-css/semantic.min.css\";\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./components/App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}