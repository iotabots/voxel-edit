{"version":3,"sources":["components/Viewport.js","components/Brush.js","components/ColorPalette.js","components/GUIController.js","modules/VoxelWorld.js","modules/Brush.js","modules/ColorPalette.js","modules/VoxelsEditor.js","components/VoxelManager.js","components/App.js","index.js"],"names":["Viewport","props","canvasRef","React","createRef","this","onCanvasCreation","className","ref","Component","Brush","handleBrushClick","e","name","setState","activeBrush","onBrushChange","state","Fragment","Menu","Item","active","onClick","ColorCell","color","id","isActive","getRGB255","r","g","b","onColorCellClick","style","backgroundColor","ColorPalette","updateColorData","onGetColorData","currentColor","selectedColorIndex","isColorsFull","newState","Object","keys","length","handlePickerChange","rgb","onSelectedColorChange","onNewSelectedColor","onAddCellClick","onAddColor","getColorCells","buttons","colors","forEach","index","push","getAddColorCell","Icon","disableAlpha","onChange","GUIController","updateMobileState","isMobile","window","innerWidth","handleAccordionIndicesChange","componentName","desktop","activeAccordionIndices","pos","indexOf","splice","createDesktopBrush","brushSettings","Segment","Group","inverted","Header","as","Content","Subheader","Accordion","fluid","exclusive","Title","includes","content","titleProps","vertical","createDesktopColorPalette","colorPalette","mobile","isColorModalOpen","addEventListener","removeEventListener","Sidebar","Pushable","border","borderRadius","direction","visible","width","Grid","Row","Column","height","overflowY","marginTop","padding","createDesktopViewport","innerHeight","Modal","open","onClose","onOpen","scrolling","Description","Actions","Button","primary","createMobileGUI","createDesktopGUI","VoxelWorld","options","cellSize","tileSize","tileTextureWidth","tileTextureHeight","material","cellSliceSize","cells","cellIdToMesh","neighborOffsets","x","y","z","voxelX","THREE","euclideanModulo","cellX","Math","floor","cellY","cellZ","cellId","computeCellId","cell","Uint8Array","v","addCell","getCellForVoxel","addCellForVoxel","voxelOffset","computeVoxelOffset","positions","normals","uvs","indices","startX","startY","startZ","voxelY","voxelZ","voxel","getVoxel","uvVoxel","faces","dir","corners","uvRow","ndx","uv","getColorAtIndex","start","end","dx","dy","dz","lenSq","len","sqrt","t","ix","iy","iz","stepX","stepY","stepZ","txDelta","abs","tyDelta","tzDelta","xDist","yDist","zDist","txMax","Infinity","tyMax","tzMax","steppedIndex","position","normal","scene","updatedCellIds","offset","ox","oy","oz","updateCellGeometry","mesh","geometry","generateGeometryDataForCell","setAttribute","Float32Array","setIndex","computeBoundingSphere","add","set","cellKeys","regex","cellKey","match","parseInt","brush","setCurrentBrush","brushName","brushOptions","currentBrush","remove","paint","selectedColor","Color","maxColors","randInt","min","max","random","VoxelEditor","render","renderRequested","undefined","resizeRendererToDisplaySize","renderer","camera","aspect","canvas","clientWidth","clientHeight","updateProjectionMatrix","controls","update","requestRenderIfNotRequested","requestAnimationFrame","recordStartPosition","event","mouse","clientX","clientY","moveX","moveY","recordMovement","placeVoxelIfNoMovement","placeVoxel","world","setColorAtIndex","updateWorldGeometry","setSelectedColor","createCamera","createOrbitControls","background","addLight","side","alphaTest","transparent","vertexColors","setVoxel","createFlatGround","preventDefault","passive","fov","near","far","OrbitControls","target","light","domElement","needResize","setSize","rect","getBoundingClientRect","left","top","getCanvasRelativePosition","setFromMatrixPosition","matrixWorld","unproject","intersection","intersectRay","voxelId","getSelectedColorIndex","map","updateVoxelGeometry","VoxelManager","createVoxelWorld","voxelEditor","current","getSelectedColor","getColorsArray","addColor","App","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.d55bcb3a.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./Viewport.css\";\n\n/**\n * Handles the 3D viewport and surrounding GUI for the application.\n * @property {Ref} canvasRef - Reference to the canvas\n *\n * @extends React.Component\n */\nclass Viewport extends React.Component {\n  constructor(props) {\n    super(props);\n\n    // Reference to canvas element\n    this.canvasRef = React.createRef();\n  }\n\n  componentDidMount() {\n    // Canvas is ready to be drawn on\n    this.props.onCanvasCreation(this.canvasRef);\n  }\n\n  render() {\n    return <canvas className=\"viewportCanvas\" ref={this.canvasRef} />;\n  }\n}\n\nexport default Viewport;\n","import React from \"react\";\nimport { Menu } from \"semantic-ui-react\";\n\n/**\n * Allows user to switch between basic brush options such as add, remove, and paint.\n * @extends React.Component\n */\nclass Brush extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      activeBrush: \"add\",\n    };\n  }\n\n  componentDidMount() {\n    // Send the initial brush name to parent component\n    this.props.onBrushChange(this.state.activeBrush);\n  }\n\n  /**\n   * Handler for each brush option. Upon click, updates the currently\n   * selected brush.\n   * @param {Event} e - React's original SyntheticEvent\n   * @param {data} props - Prop data from the Menu.Item\n   */\n  handleBrushClick = (e, { name }) => {\n    // Update state with current brush.\n    this.setState({ activeBrush: name });\n\n    // Send active brush name to parent component\n    this.props.onBrushChange(name);\n  };\n\n  render() {\n    const { activeBrush } = this.state;\n\n    return (\n      <React.Fragment>\n        <Menu.Item\n          name=\"add\"\n          active={activeBrush === \"add\"}\n          onClick={this.handleBrushClick}\n        >\n          Add Voxel\n        </Menu.Item>\n        <Menu.Item\n          name=\"remove\"\n          active={activeBrush === \"remove\"}\n          onClick={this.handleBrushClick}\n        >\n          Remove Voxel\n        </Menu.Item>\n        <Menu.Item\n          name=\"paint\"\n          active={activeBrush === \"paint\"}\n          onClick={this.handleBrushClick}\n        >\n          Paint Voxel\n        </Menu.Item>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default Brush;\n","import React from \"react\";\nimport \"./ColorPalette.css\";\nimport { ChromePicker } from \"react-color\";\nimport { Icon } from \"semantic-ui-react\";\n\n/**\n * Represents each individual color on the color palette.\n * @param {*} props\n * @returns {JSX}\n */\nconst ColorCell = (props) => {\n  const { color, id, isActive } = props;\n  const { r, g, b } = color.getRGB255();\n\n  return (\n    <div\n      onClick={() => {\n        props.onColorCellClick(id, { r, g, b });\n      }}\n      className={`color-cell ${isActive ? \"active\" : \"\"}`}\n      style={{\n        backgroundColor: `rgb(${r}, ${g}, ${b})`,\n      }}\n    ></div>\n  );\n};\n\n/**\n * Allows the user to select what colors they wish to paint with,\n * choose new colors to paint with, and select the color that they\n * are currently painting with.\n * @extends React.Component\n */\nclass ColorPalette extends React.Component {\n  constructor(props) {\n    super(props);\n\n    // Get data from parent component\n    const {\n      currentColor,\n      selectedColorIndex,\n      isColorsFull,\n    } = this.props.onGetColorData();\n\n    this.state = {\n      currentColor,\n      selectedColorIndex,\n      isColorsFull,\n    };\n  }\n\n  /**\n   * Checks for changes in color data from the onGetColorData() prop. If\n   * there are any, updates the state.\n   */\n  updateColorData = () => {\n    const {\n      currentColor,\n      selectedColorIndex,\n      isColorsFull,\n    } = this.props.onGetColorData();\n\n    let newState = {};\n\n    if (this.state.isColorsFull !== isColorsFull) {\n      newState.isColorsFull = isColorsFull;\n    }\n\n    if (this.state.selectedColorIndex !== selectedColorIndex) {\n      newState.selectedColorIndex = selectedColorIndex;\n    }\n\n    const { r, g, b } = this.state.currentColor;\n    if (r !== currentColor.r || g !== currentColor.g || b !== currentColor.b) {\n      newState.currentColor = currentColor;\n    }\n\n    if (Object.keys(newState).length !== 0) {\n      this.setState(newState);\n    }\n  };\n\n  componentDidUpdate() {\n    this.updateColorData();\n  }\n\n  /**\n   * Handles color picker change.\n   * @param {*} rgb\n   */\n  handlePickerChange = ({ rgb }) => {\n    // Tell the parent that there was a change in color\n    this.props.onSelectedColorChange(this.state.selectedColorIndex, rgb);\n\n    this.updateColorData();\n  };\n\n  /**\n   * Updates the currently selected color cell to the given id\n   * @param {number} id\n   * @param {string} color - Color of the cell\n   */\n  onColorCellClick = (id, color) => {\n    // Tell the parent that there is a new selected color/cell\n    this.props.onNewSelectedColor(id);\n\n    this.updateColorData();\n  };\n\n  /**\n   * Handles when the add cell button is clicked.\n   */\n  onAddCellClick = () => {\n    // Add a new color to the palette\n    this.props.onAddColor();\n\n    this.updateColorData();\n  };\n\n  /**\n   * Creates the JSX for all of the color select buttons.\n   * @returns {JSX}\n   */\n  getColorCells = () => {\n    // Create buttons for each color\n    let buttons = [];\n    const { colors } = this.props.onGetColorData();\n    colors.forEach((color, index) => {\n      buttons.push(\n        <ColorCell\n          key={index}\n          id={index}\n          onColorCellClick={this.onColorCellClick}\n          color={color}\n          isActive={index === this.state.selectedColorIndex}\n        />\n      );\n    });\n\n    return buttons;\n  };\n\n  /**\n   * Creates the JSX for the add color cell. If the internal ColorPalette's\n   * colors array is full, returns null instead.\n   * @returns {JSX}\n   */\n  getAddColorCell = () => {\n    if (this.state.isColorsFull) return null;\n\n    return (\n      <div className=\"color-cell add-cell-btn\" onClick={this.onAddCellClick}>\n        <Icon name=\"plus\" />\n      </div>\n    );\n  };\n\n  render() {\n    return (\n      <div>\n        <div className=\"color-cell-container\">\n          {this.getColorCells()}\n          {this.getAddColorCell()}\n        </div>\n        <ChromePicker\n          color={this.state.currentColor}\n          disableAlpha={true}\n          onChange={this.handlePickerChange}\n        />\n      </div>\n    );\n  }\n}\n\nexport default ColorPalette;\n","import React from \"react\";\nimport Viewport from \"./Viewport\";\nimport Brush from \"./Brush\";\nimport ColorPalette from \"./ColorPalette\";\nimport \"./GUIController.css\";\nimport {\n  Modal,\n  Button,\n  Grid,\n  Sidebar,\n  Segment,\n  Menu,\n  Accordion,\n  Header,\n  Icon,\n} from \"semantic-ui-react\";\n\n/**\n * Handles switching between both desktop and mobile versions of the\n * UI. Whenever one of its chidlren updates, it will pass that data\n * up to its parent component.\n * @extends React.Component\n */\nclass GUIController extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      isMobile: false,\n      mobile: {\n        isColorModalOpen: false,\n      },\n      desktop: {\n        brushSettings: {\n          activeAccordionIndices: [0],\n        },\n        colorPalette: {\n          activeAccordionIndices: [0],\n        },\n      },\n    };\n  }\n\n  /**\n   * Handler for screen resize events that updates whether or not the application\n   * should currently be using the mobile or desktop GUI.\n   */\n  updateMobileState = () => {\n    // If width below 768, use mobile GUI\n    const isMobile = window.innerWidth < 768;\n    this.setState({ isMobile });\n  };\n\n  /**\n   * Toggles the accordion at the given index for the given state with a\n   * activeAccordionIndices property.\n   * @param {number} index - Index of accordion to toggle\n   * @param {string} componentName - The state.desktop property with a activeAccordionIndices property\n   */\n  handleAccordionIndicesChange = (index, componentName) => {\n    // Make a copy of the desktop state object\n    const desktop = { ...this.state.desktop };\n\n    // Get the active indices for that component\n    const { activeAccordionIndices } = desktop[componentName];\n\n    // Get the position of the accordion index\n    const pos = activeAccordionIndices.indexOf(index);\n\n    // Position was found, remove the index for the user is closing the accordion\n    if (pos !== -1) {\n      activeAccordionIndices.splice(pos, 1);\n    }\n    // Position not found, add the index\n    else {\n      activeAccordionIndices.push(index);\n    }\n\n    // Update the state of the active indices for the given component\n    this.setState({ desktop });\n  };\n\n  componentDidMount() {\n    // Perform initial check for mobile device\n    this.updateMobileState();\n    window.addEventListener(\"resize\", this.updateMobileState);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener(\"resize\", this.updateMobileState);\n  }\n\n  /**\n   * Creates the JSX for the desktop version of the viewport.\n   * @returns {JSX}\n   */\n  createDesktopViewport() {\n    return (\n      <Sidebar.Pushable\n        as={Segment}\n        style={{ border: \"none\", borderRadius: \"0\" }}\n      >\n        <Sidebar as={Menu} inverted direction=\"top\" visible width=\"very thin\">\n          <Menu.Item as=\"a\">Button 1</Menu.Item>\n          <Menu.Item as=\"a\">Button 2</Menu.Item>\n        </Sidebar>\n        <Viewport onCanvasCreation={this.props.onCanvasCreation} />\n      </Sidebar.Pushable>\n    );\n  }\n\n  /**\n   * Creates the JSX for the desktop version of the brush.\n   * @returns {JSX}\n   */\n  createDesktopBrush = () => {\n    const { brushSettings } = this.state.desktop;\n\n    return (\n      <Segment.Group>\n        <Segment inverted>\n          <Header as=\"h4\" inverted>\n            <Icon name=\"paint brush\" />\n            <Header.Content>\n              Brush Settings\n              <Header.Subheader>Add, remove, or paint voxels</Header.Subheader>\n            </Header.Content>\n          </Header>\n\n          <Accordion inverted fluid exclusive={false}>\n            <Accordion.Title\n              active={brushSettings.activeAccordionIndices.includes(0)}\n              content=\"Brush Action\"\n              index={0}\n              onClick={(e, titleProps) => {\n                this.handleAccordionIndicesChange(\n                  titleProps.index,\n                  \"brushSettings\"\n                );\n              }}\n            />\n            <Accordion.Content\n              active={brushSettings.activeAccordionIndices.includes(0)}\n            >\n              <Menu inverted vertical fluid>\n                <Brush onBrushChange={this.props.onBrushChange} />\n              </Menu>\n            </Accordion.Content>\n          </Accordion>\n        </Segment>\n      </Segment.Group>\n    );\n  };\n\n  /**\n   * Creates the JSX for the desktop version of the color palette.\n   * @returns {JSX}\n   */\n  createDesktopColorPalette = () => {\n    const { colorPalette } = this.state.desktop;\n\n    return (\n      <Segment.Group>\n        <Segment inverted>\n          <Header as=\"h4\" inverted>\n            <Icon name=\"tint\" />\n            <Header.Content>\n              Color Palette\n              <Header.Subheader>Select a color to paint with</Header.Subheader>\n            </Header.Content>\n          </Header>\n          <Accordion inverted fluid exclusive={false}>\n            <Accordion.Title\n              active={colorPalette.activeAccordionIndices.includes(0)}\n              content=\"Color Selection\"\n              index={0}\n              onClick={(e, titleProps) => {\n                this.handleAccordionIndicesChange(\n                  titleProps.index,\n                  \"colorPalette\"\n                );\n              }}\n            />\n            <Accordion.Content\n              active={colorPalette.activeAccordionIndices.includes(0)}\n            >\n              <ColorPalette\n                onGetColorData={this.props.onGetColorData}\n                onSelectedColorChange={this.props.onSelectedColorChange}\n                onNewSelectedColor={this.props.onNewSelectedColor}\n                onAddColor={this.props.onAddColor}\n              />\n            </Accordion.Content>\n          </Accordion>\n        </Segment>\n      </Segment.Group>\n    );\n  };\n\n  /**\n   * Create the desktop version of the UI.\n   * @returns {JSX}\n   */\n  createDesktopGUI() {\n    return (\n      <Grid className={\"desktopGrid\"}>\n        <Grid.Row>\n          <Grid.Column\n            width={3}\n            style={{\n              height: \"100vh\",\n              overflowY: \"auto\",\n              marginTop: \"1em\",\n            }}\n          >\n            {this.createDesktopBrush()}\n            {this.createDesktopColorPalette()}\n          </Grid.Column>\n\n          <Grid.Column width={11} style={{ padding: \"0\" }}>\n            {this.createDesktopViewport()}\n          </Grid.Column>\n\n          <Grid.Column width={2}>\n            <h1>Right Panel</h1>\n          </Grid.Column>\n        </Grid.Row>\n      </Grid>\n    );\n  }\n\n  /**\n   * Create the mobile version of the UI.\n   * @returns {JSX}\n   */\n  createMobileGUI() {\n    return (\n      <div style={{ height: window.innerHeight }}>\n        <Sidebar.Pushable\n          as={Segment}\n          style={{ border: \"none\", borderRadius: \"0\" }}\n        >\n          <Sidebar as={Menu} inverted direction=\"top\" visible width=\"very thin\">\n            <Menu.Item\n              as=\"a\"\n              onClick={() =>\n                this.setState({ mobile: { isColorModalOpen: true } })\n              }\n            >\n              Color Palette\n            </Menu.Item>\n            <Menu.Item as=\"a\">Edit</Menu.Item>\n            <Menu.Item as=\"a\">Camera</Menu.Item>\n            <Menu.Item as=\"a\">Project</Menu.Item>\n          </Sidebar>\n\n          {/* Color Selection Modal */}\n          <Modal\n            open={this.state.mobile.isColorModalOpen}\n            onClose={() =>\n              this.setState({ mobile: { isColorModalOpen: false } })\n            }\n            onOpen={() => this.setState({ mobile: { isColorModalOpen: true } })}\n          >\n            <Modal.Header>Color Palette</Modal.Header>\n            <Modal.Content scrolling>\n              <Modal.Description>\n                <ColorPalette\n                  onGetColorData={this.props.onGetColorData}\n                  onSelectedColorChange={this.props.onSelectedColorChange}\n                  onNewSelectedColor={this.props.onNewSelectedColor}\n                  onAddColor={this.props.onAddColor}\n                />\n              </Modal.Description>\n            </Modal.Content>\n\n            <Modal.Actions>\n              <Button\n                onClick={() =>\n                  this.setState({ mobile: { isColorModalOpen: false } })\n                }\n                primary\n              >\n                Close\n              </Button>\n            </Modal.Actions>\n          </Modal>\n\n          <Sidebar as={Menu} inverted direction=\"bottom\" visible width=\"thin\">\n            <Brush onBrushChange={this.props.onBrushChange} />\n          </Sidebar>\n\n          <Viewport onCanvasCreation={this.props.onCanvasCreation} />\n        </Sidebar.Pushable>\n      </div>\n    );\n  }\n\n  render() {\n    return this.state.isMobile\n      ? this.createMobileGUI()\n      : this.createDesktopGUI();\n  }\n}\n\nexport default GUIController;\n","import * as THREE from \"three\";\n\n/**\n * Manages voxel data.\n * At the top level, a single VoxelWorld consists of cells. Each cell is a 'chunk' of the world\n * that consists of voxels (i.e. cubes). In order to optimize render times, we merge the geometry\n * of all the voxels within a single cell and make a single render call (as opposed to rendering\n * each individual voxel). In addition, a single cell is essentially a 3D grid that voxels are\n * placed in. Each cell has a length, width, and height dictated by the cellSize variable. This could\n * be set to anything but is perhaps best capped at 128 or 256 (256^3 is 16,777,216 voxels!).\n *\n * @property {number} cellSize      - The length, width, and height of a single cell (or chunk) within the world\n * @property {number} cellSliceSize - The area of a single slice of each cell (cellSize^2)\n * @property {Object} cell          - Object consisting of an array for each cell\n */\nclass VoxelWorld {\n  /**\n   * Creates a VoxelWorld object with the given options\n   * @param {Object} options - Options to spawn the world with\n   * @param {number} options.cellSize - The length, width, and height of each cell\n   * @param {number} options.tileSize - The size of each tile from a texture atlas\n   * @param {number} options.tileTextureWidth - The width of the texture atlas\n   * @param {number} options.tileTextureHeight - The height of the texture atlas\n   * @param {*} options.material - The material that the VoxelWorld should use for its meshes\n   * @param {ColorPalette} options.colorPalette- The current color palette that the world is using\n   */\n  constructor(options) {\n    this.cellSize = options.cellSize;\n    this.tileSize = options.tileSize;\n    this.tileTextureWidth = options.tileTextureWidth;\n    this.tileTextureHeight = options.tileTextureHeight;\n    this.material = options.material;\n    this.colorPalette = options.colorPalette;\n    this.cellSliceSize = this.cellSize * this.cellSize;\n    this.cells = options.cells;\n\n    // Used in the updateCellGeometry() function\n    // Tracks the meshes for each cell\n    this.cellIdToMesh = {};\n\n    // Used in updateVoxelGeometry() function\n    this.neighborOffsets = [\n      [0, 0, 0], // self\n      [-1, 0, 0], // left\n      [1, 0, 0], // right\n      [0, -1, 0], // down\n      [0, 1, 0], // up\n      [0, 0, -1], // back\n      [0, 0, 1], // front\n    ];\n  }\n\n  /**\n   * Returns the offset, or index, to the voxel within the cell array\n   * at the given x, y, and z coordinates.\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   * @returns {number} Index to the voxel within the cell array\n   */\n  computeVoxelOffset(x, y, z) {\n    const { cellSize, cellSliceSize } = this;\n\n    // Note, the \"| 0\" actually TRUNCATES the value! Not quite the same as flooring\n    // https://stackoverflow.com/questions/7487977/using-bitwise-or-0-to-floor-a-number\n    // Also, euclideanModulo(n, m) is the equivalent of (( n % m ) + m ) % m\n    const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;\n    const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;\n    const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;\n\n    // Return index voxel is located at\n    return voxelY * cellSliceSize + voxelZ * cellSize + voxelX;\n  }\n\n  /**\n   * Computes the id of the cell stored as a key in this.cells based\n   * on the given x, y, and z coordinates of a voxel.\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   * @returns {string} The id of the cell in the form of \"(x,y,z)\"\n   */\n  computeCellId(x, y, z) {\n    const { cellSize } = this;\n    const cellX = Math.floor(x / cellSize);\n    const cellY = Math.floor(y / cellSize);\n    const cellZ = Math.floor(z / cellSize);\n    return `${cellX},${cellY},${cellZ}`;\n  }\n\n  /**\n   * Adds a new cell for a voxel at the given x, y, and z coordinates if a\n   * cell doesn't already exist to accomodate it.\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   * @returns {Uint8Array} Array of voxels for the cell\n   */\n  addCellForVoxel(x, y, z) {\n    // Get the id of the cell corresponding to the x, y, and z coordinate\n    const cellId = this.computeCellId(x, y, z);\n\n    // Get the array of voxels associated with the cellId\n    let cell = this.cells[cellId];\n\n    // If cell doesn't exist, add it\n    if (!cell) {\n      const { cellSize } = this;\n      cell = new Uint8Array(cellSize * cellSize * cellSize);\n      this.cells[cellId] = cell;\n    }\n\n    // Return the cell\n    return cell;\n  }\n\n  /**\n   * Finds the corresponding voxel array for the cell for the given voxel coordinates.\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   * @returns {Uint8Array} Array of voxels.\n   */\n  getCellForVoxel(x, y, z) {\n    return this.cells[this.computeCellId(x, y, z)];\n  }\n\n  /**\n   * Sets voxel at given coordinates.\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   * @param {number} v - The type of voxel to add\n   * @param {boolean} addCell - If true, a new cell will be created to accomodate the voxel if needed\n   */\n  setVoxel(x, y, z, v, addCell = true) {\n    // Get the array of voxels corresponding to the x, y, and z coordinates\n    let cell = this.getCellForVoxel(x, y, z);\n\n    // No cell was found\n    if (!cell) {\n      // If addCell is false, return\n      if (!addCell) {\n        return;\n      }\n      // Otherwise, create a new cell for the voxel\n      cell = this.addCellForVoxel(x, y, z);\n    }\n\n    // Find the index to add the new voxel within the found cell\n    const voxelOffset = this.computeVoxelOffset(x, y, z);\n\n    // Set the new voxel\n    cell[voxelOffset] = v;\n  }\n\n  /**\n   * Gets the corresponding voxel at the given coordinates.\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   * @returns {number} Number representing the type of voxel\n   */\n  getVoxel(x, y, z) {\n    // Find the cell that has the voxel at the given coordinates\n    const cell = this.getCellForVoxel(x, y, z);\n\n    // No such cell exists! Default by returning 0\n    if (!cell) {\n      return 0;\n    }\n\n    // Find the index of the voxel within the cell\n    const voxelOffset = this.computeVoxelOffset(x, y, z);\n\n    // Return the voxel that was found\n    return cell[voxelOffset];\n  }\n\n  /**\n   * Generates geometry data for a cell at the given coordinate. Similar to voxels, each cell\n   * is a part of a 3D grid as well.\n   * @example\n   * generateGeometryDataForCell(0, 0, 0);  // Cell created at (0, 0, 0) coordinate\n   * generateGeometryDataForCell(0, 1, 0);  // Cell created above the last one at (0, 1, 0)\n   *\n   * @param {number} cellX\n   * @param {number} cellY\n   * @param {number} cellZ\n   */\n  generateGeometryDataForCell(cellX, cellY, cellZ) {\n    const { cellSize, tileSize, tileTextureWidth, tileTextureHeight } = this;\n\n    // Used for generating the geometry of the final mesh formed by the voxels\n    const positions = [];\n    const normals = [];\n    const uvs = [];\n    const indices = [];\n    const colors = [];\n\n    // Calculate origin point of the cell i.e. (0, 0, 0)\n    const startX = cellX * cellSize;\n    const startY = cellY * cellSize;\n    const startZ = cellZ * cellSize;\n\n    // Iterate over y coords\n    for (let y = 0; y < cellSize; ++y) {\n      const voxelY = startY + y;\n      // Iterate over z coords\n      for (let z = 0; z < cellSize; ++z) {\n        const voxelZ = startZ + z;\n        // Iterate over x coords\n        for (let x = 0; x < cellSize; ++x) {\n          const voxelX = startX + x;\n\n          // Get voxel at current x, y, and z coords\n          const voxel = this.getVoxel(voxelX, voxelY, voxelZ);\n\n          // Check if voxel exists (by default, a voxel 0 is empty)\n          if (voxel) {\n            // voxel 0 is sky so for UVs we start at 0\n            const uvVoxel = voxel - 1;\n\n            // There is a voxel here but do we need faces for it?\n            for (const { dir, corners, uvRow } of VoxelWorld.faces) {\n              // The neighboring voxel to the face of our voxel\n              const neighbor = this.getVoxel(\n                voxelX + dir[0],\n                voxelY + dir[1],\n                voxelZ + dir[2]\n              );\n\n              // neighbor voxel is empty (0) in this direction so we need a face\n              if (!neighbor) {\n                // Used to define the indices\n                const ndx = positions.length / 3;\n\n                // Add vertices for the face of the voxel and normals too\n                for (const { pos, uv } of corners) {\n                  positions.push(pos[0] + x, pos[1] + y, pos[2] + z);\n                  normals.push(...dir);\n\n                  // TODO: uv's no longer being used. Might be added in the future though\n                  // Calculates where to grab texture from the texture atlas\n                  // uvVoxel corresponds to the column and uvRow the row to get the texture\n                  uvs.push(\n                    ((uvVoxel + uv[0]) * tileSize) / tileTextureWidth,\n                    1 - ((uvRow + 1 - uv[1]) * tileSize) / tileTextureHeight\n                  );\n\n                  // Add color. Subtract 1 for empty voxels do not correspond with palette array\n                  const color = this.colorPalette.getColorAtIndex(voxel - 1);\n                  colors.push(color.r, color.g, color.b);\n                }\n\n                // Add indices used to draw the face\n                indices.push(ndx, ndx + 1, ndx + 2, ndx + 2, ndx + 1, ndx + 3);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Return object consisting of geometry data for the voxel model\n    return {\n      positions,\n      normals,\n      uvs,\n      indices,\n      colors,\n    };\n  }\n\n  /**\n   * Algorithm for raycasting specialized for use with voxels. Used to check if the\n   * user clicked a voxel in the scene and returns information related to it such as\n   * the coordinates of the successful hit.\n   * The code itself is based upon this paper: http://www.cse.chalmers.se/edu/year/2010/course/TDA361/grid.pdf\n   * @param {*} start\n   * @param {*} end\n   * @returns {Object} HitResults or null if nothing was hit\n   * @returns {Array.<number>} HitResults.position Coordinates of the hit\n   * @returns {Array.<number} HitResults.normal Normal of the hit\n   * @returns {number} HitResults.voxel The type of voxel hit\n   */\n  intersectRay(start, end) {\n    // Get the direction that ray is cast\n    let dx = end.x - start.x;\n    let dy = end.y - start.y;\n    let dz = end.z - start.z;\n\n    // Find the magnitude of the above direction\n    const lenSq = dx * dx + dy * dy + dz * dz;\n    const len = Math.sqrt(lenSq);\n\n    // Change to unit vector so we only have the direction of the ray cast\n    dx /= len;\n    dy /= len;\n    dz /= len;\n\n    // t is a scalar that we use to 'stretch' the ray into the scene to test for intersections\n    let t = 0.0;\n    let ix = Math.floor(start.x);\n    let iy = Math.floor(start.y);\n    let iz = Math.floor(start.z);\n\n    // Dictates how we 'step' from voxel to voxel\n    const stepX = dx > 0 ? 1 : -1;\n    const stepY = dy > 0 ? 1 : -1;\n    const stepZ = dz > 0 ? 1 : -1;\n\n    // The amount of change required to advance one whole voxel\n    const txDelta = Math.abs(1 / dx);\n    const tyDelta = Math.abs(1 / dy);\n    const tzDelta = Math.abs(1 / dz);\n\n    const xDist = stepX > 0 ? ix + 1 - start.x : start.x - ix;\n    const yDist = stepY > 0 ? iy + 1 - start.y : start.y - iy;\n    const zDist = stepZ > 0 ? iz + 1 - start.z : start.z - iz;\n\n    // location of nearest voxel boundary, in units of t\n    let txMax = txDelta < Infinity ? txDelta * xDist : Infinity;\n    let tyMax = tyDelta < Infinity ? tyDelta * yDist : Infinity;\n    let tzMax = tzDelta < Infinity ? tzDelta * zDist : Infinity;\n\n    // Represents the direction we last stepped in. Either x, y, or z\n    let steppedIndex = -1;\n\n    // main loop along raycast vector\n    while (t <= len) {\n      // Get the voxel at the ix, iy, and iz coordinate\n      const voxel = this.getVoxel(ix, iy, iz);\n\n      // Found a non-empty voxel! Return hit information\n      if (voxel) {\n        return {\n          position: [start.x + t * dx, start.y + t * dy, start.z + t * dz],\n          normal: [\n            steppedIndex === 0 ? -stepX : 0,\n            steppedIndex === 1 ? -stepY : 0,\n            steppedIndex === 2 ? -stepZ : 0,\n          ],\n          voxel,\n        };\n      }\n\n      // advance t to next nearest voxel boundary\n      // This is the core if-statement from the research paper\n      if (txMax < tyMax) {\n        if (txMax < tzMax) {\n          ix += stepX;\n          t = txMax;\n          txMax += txDelta;\n          steppedIndex = 0;\n        } else {\n          iz += stepZ;\n          t = tzMax;\n          tzMax += tzDelta;\n          steppedIndex = 2;\n        }\n      } else {\n        if (tyMax < tzMax) {\n          iy += stepY;\n          t = tyMax;\n          tyMax += tyDelta;\n          steppedIndex = 1;\n        } else {\n          iz += stepZ;\n          t = tzMax;\n          tzMax += tzDelta;\n          steppedIndex = 2;\n        }\n      }\n    }\n\n    // Nothing was found, return null\n    return null;\n  }\n\n  /**\n   * Updates the voxel of a cell at the given x, y, and z coordinates. Also,\n   * updates any cells that the voxel is adjacent to.\n   * @param scene - The scene to add the final mesh to\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   */\n  updateVoxelGeometry(scene, x, y, z) {\n    const updatedCellIds = {};\n\n    // Check the cell and all surrounding cells when updating voxel geometry\n    for (const offset of this.neighborOffsets) {\n      // Get the coordinates of the current cell to update\n      const ox = x + offset[0];\n      const oy = y + offset[1];\n      const oz = z + offset[2];\n\n      // Get the id of the cell we wish to update\n      const cellId = this.computeCellId(ox, oy, oz);\n\n      // If cell yet not updated, update it!\n      if (!updatedCellIds[cellId]) {\n        updatedCellIds[cellId] = true;\n\n        // Update the cell's geometry\n        this.updateCellGeometry(scene, ox, oy, oz);\n      }\n    }\n  }\n\n  /**\n   * Updates the geometry of the cell with the given coordinates within\n   * the scene.\n   * @param scene - The scene to add the final mesh to\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   */\n  updateCellGeometry(scene, x, y, z) {\n    const { cellSize } = this;\n\n    // Find the cell corresponding to the voxel at the x, y, and z coordinates\n    const cellX = Math.floor(x / cellSize);\n    const cellY = Math.floor(y / cellSize);\n    const cellZ = Math.floor(z / cellSize);\n    const cellId = this.computeCellId(x, y, z);\n\n    // Get the mesh corresponding to the given cellId\n    let mesh = this.cellIdToMesh[cellId];\n    // Get the geometry of the mesh. If no mesh exists, create new geometry\n    const geometry = mesh ? mesh.geometry : new THREE.BufferGeometry();\n\n    // Retrieve data for making the geometry for a given cell\n    const {\n      positions,\n      normals,\n      //uvs,\n      indices,\n      colors,\n    } = this.generateGeometryDataForCell(cellX, cellY, cellZ);\n\n    // Set position (vertex) data of cell\n    const positionNumComponents = 3;\n    geometry.setAttribute(\n      \"position\",\n      new THREE.BufferAttribute(\n        new Float32Array(positions),\n        positionNumComponents\n      )\n    );\n\n    // Set normal data for cell\n    const normalNumComponents = 3;\n    geometry.setAttribute(\n      \"normal\",\n      new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents)\n    );\n\n    // TODO: Add back if supporting textures\n    // Set uv data for cell\n    /*\n    const uvNumComponents = 2;\n    geometry.setAttribute(\n      \"uv\",\n      new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents)\n    );\n    */\n\n    const rgbNumComponents = 3;\n    geometry.setAttribute(\n      \"color\",\n      new THREE.BufferAttribute(new Float32Array(colors), rgbNumComponents)\n    );\n\n    // Set index data for cell\n    geometry.setIndex(indices);\n\n    // Comput bounding sphere of the geometry\n    geometry.computeBoundingSphere();\n\n    // If the mesh has not yet been created, create it!\n    if (!mesh) {\n      mesh = new THREE.Mesh(geometry, this.material);\n      mesh.name = cellId;\n      this.cellIdToMesh[cellId] = mesh;\n      scene.add(mesh);\n      mesh.position.set(cellX * cellSize, cellY * cellSize, cellZ * cellSize);\n    }\n  }\n\n  /**\n   * Updates every single cell within the world. Useful for when loading in\n   * a brand new world.\n   * @param {*} scene\n   */\n  updateWorldGeometry(scene) {\n    // Get an array of every cell's key\n    const cellKeys = Object.keys(this.cells);\n\n    // Regex used to extract cell position\n    let regex = /^(-?\\d+),(-?\\d+),(-?\\d+)$/;\n\n    // Update every cell\n    cellKeys.forEach((cellKey) => {\n      // Extract the x, y, and z position of the cell\n      let match = cellKey.match(regex);\n      const x = parseInt(match[1], 10);\n      const y = parseInt(match[2], 10);\n      const z = parseInt(match[3], 10);\n\n      // Update that cell\n      this.updateCellGeometry(\n        scene,\n        x * this.cellSize,\n        y * this.cellSize,\n        z * this.cellSize\n      );\n    });\n  }\n}\n\n/**\n * Array of objects that represent each face of a single voxel.\n * uvRow is the row of the texture atlas to grab an image from\n * dir is the direction of the face\n * corners consist of vertices and uv coordinates for the texture\n */\nVoxelWorld.faces = [\n  {\n    // left\n    uvRow: 0,\n    dir: [-1, 0, 0],\n    corners: [\n      { pos: [0, 1, 0], uv: [0, 1] },\n      { pos: [0, 0, 0], uv: [0, 0] },\n      { pos: [0, 1, 1], uv: [1, 1] },\n      { pos: [0, 0, 1], uv: [1, 0] },\n    ],\n  },\n  {\n    // right\n    uvRow: 0,\n    dir: [1, 0, 0],\n    corners: [\n      { pos: [1, 1, 1], uv: [0, 1] },\n      { pos: [1, 0, 1], uv: [0, 0] },\n      { pos: [1, 1, 0], uv: [1, 1] },\n      { pos: [1, 0, 0], uv: [1, 0] },\n    ],\n  },\n  {\n    // bottom\n    uvRow: 1,\n    dir: [0, -1, 0],\n    corners: [\n      { pos: [1, 0, 1], uv: [1, 0] },\n      { pos: [0, 0, 1], uv: [0, 0] },\n      { pos: [1, 0, 0], uv: [1, 1] },\n      { pos: [0, 0, 0], uv: [0, 1] },\n    ],\n  },\n  {\n    // top\n    uvRow: 2,\n    dir: [0, 1, 0],\n    corners: [\n      { pos: [0, 1, 1], uv: [1, 1] },\n      { pos: [1, 1, 1], uv: [0, 1] },\n      { pos: [0, 1, 0], uv: [1, 0] },\n      { pos: [1, 1, 0], uv: [0, 0] },\n    ],\n  },\n  {\n    // back\n    uvRow: 0,\n    dir: [0, 0, -1],\n    corners: [\n      { pos: [1, 0, 0], uv: [0, 0] },\n      { pos: [0, 0, 0], uv: [1, 0] },\n      { pos: [1, 1, 0], uv: [0, 1] },\n      { pos: [0, 1, 0], uv: [1, 1] },\n    ],\n  },\n  {\n    // front\n    uvRow: 0,\n    dir: [0, 0, 1],\n    corners: [\n      { pos: [0, 0, 1], uv: [0, 0] },\n      { pos: [1, 0, 1], uv: [1, 0] },\n      { pos: [0, 1, 1], uv: [0, 1] },\n      { pos: [1, 1, 1], uv: [1, 1] },\n    ],\n  },\n];\n\nexport default VoxelWorld;\n","/**\n * Brush object used to determine how to paint voxels on the scene.\n */\nclass Brush {\n  constructor(brush = \"add\") {\n    this.setCurrentBrush(brush);\n  }\n\n  // Options for each brush\n  static brushOptions = {\n    add: \"add\",\n    remove: \"remove\",\n    paint: \"paint\",\n  };\n\n  /**\n   * Sets the current brush to one of the available brush options.\n   * @param {string} brushName\n   */\n  setCurrentBrush(brushName) {\n    // Get the brush to set\n    const brush = Brush.brushOptions[brushName];\n\n    // If that brush exists, set it as current\n    if (brush) {\n      this.currentBrush = brush;\n    }\n  }\n}\n\nexport default Brush;\n","/**\n * Internal representation of the ColorPalette React component.\n * Used to track each color of the voxels within the scene.\n *\n * @property {Array.<Color>} colors - Array containing all of the colors in the color palette\n * @property {number} selectedColor - The currently selected color from the colors array\n * @property {number} maxColors - The maximum number of colors that the colors array can hold\n */\nclass ColorPalette {\n  constructor(colors = null, selectedColor = 0) {\n    // Initialize the color array\n    this.colors = colors ? colors : [new Color(0.5176, 0.7843, 0.0902)];\n\n    // The currently selected color\n    this.selectedColor = selectedColor;\n\n    // The VoxelWorld can only hold up to 255 colors\n    this.maxColors = 128;\n  }\n\n  /**\n   * Adds a new color to the end of the colors array. Red by default.\n   * @param {number} [r = 1]\n   * @param {number} [g = 0]\n   * @param {number} [b = 0]\n   */\n  addColor(r = 1, g = 0, b = 0) {\n    if (!this.isColorsFull()) {\n      this.colors.push(new Color(r, g, b));\n      this.selectedColor = this.colors.length - 1;\n    }\n  }\n\n  /**\n   * Checks if the colors array is full. True if it is. False otherwise.\n   * @returns {boolean}\n   */\n  isColorsFull() {\n    return this.colors.length >= this.maxColors;\n  }\n\n  /**\n   * Sets the color at the given index to the given r, g, b values.\n   * @param {number} index\n   * @param {number} r\n   * @param {number} g\n   * @param {number} b\n   */\n  setColorAtIndex(index, r, g, b) {\n    // If index out of range, return\n    if (index < 0 || index >= this.colors.length) return;\n\n    // Set the rgb values of the color\n    this.colors[index].r = r;\n    this.colors[index].g = g;\n    this.colors[index].b = b;\n  }\n\n  /**\n   * Returns the color at the given index.\n   * @param {number} index\n   * @returns {Color} The color at the index. Null if not found\n   */\n  getColorAtIndex(index) {\n    // If index out of range, return\n    if (index < 0 || index >= this.colors.length) return null;\n    return this.colors[index];\n  }\n\n  /**\n   * Returns the currently selected color.\n   * @returns {Color}\n   */\n  getSelectedColor() {\n    return this.colors[this.selectedColor];\n  }\n\n  /**\n   * Changes the currently selected color to another within the colors array.\n   * @param {number} index\n   */\n  setSelectedColor(index) {\n    // If index out of range, return\n    if (index < 0 || index >= this.colors.length) return null;\n    this.selectedColor = index;\n  }\n\n  /**\n   * Returns the index of the selected color.\n   * @returns {number}\n   */\n  getSelectedColorIndex() {\n    return this.selectedColor;\n  }\n\n  /**\n   * Returns the array of colors currently in the palette.\n   * @returns {Array.Color}\n   */\n  getColorsArray() {\n    return this.colors;\n  }\n}\n\n/**\n * Class that represents a single rgb color with each component being from\n * 0 to 1.\n */\nclass Color {\n  constructor(r, g, b) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n  }\n\n  /**\n   * Returns a 0-255 value representation of the color.\n   * @returns {Object}\n   */\n  getRGB255() {\n    return { r: this.r * 255, g: this.g * 255, b: this.b * 255 };\n  }\n}\n\nexport default ColorPalette;\n","import * as THREE from \"three\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport VoxelWorld from \"./VoxelWorld\";\nimport Brush from \"./Brush\";\nimport ColorPalette from \"./ColorPalette\";\n//import textureAtlas from \"../images/flourish-cc-by-nc-sa.png\";\n\n/**\n * Helper function to return a random integer between the min and max value\n * in a range of [min, max).\n * TODO: This can be removed soon\n * @param {number} min\n * @param {number} max\n * @returns\n */\nfunction randInt(min, max) {\n  return Math.floor(Math.random() * (max - min) + min);\n}\n\n/**\n * Has the cell at the given coordinates form a sine wave out of its voxels.\n * @param {VoxelWorld} world - The world to spawn the sine wave in\n * @param {number} cellX\n * @param {number} cellY\n * @param {number} cellZ\n * @param {number} cellSize - Dimensions of the cell\n * @param {number} [v=0] - The type of voxel to spawn. 0 for random\n */\n/*\nfunction createSineWave(world, cellX, cellY, cellZ, cellSize, v = 0) {\n  const startX = cellX * cellSize;\n  const startY = cellY * cellSize;\n  const startZ = cellZ * cellSize;\n\n  // Create a sine wave with our voxels\n  for (let y = 0; y < cellSize; ++y) {\n    for (let z = 0; z < cellSize; ++z) {\n      for (let x = 0; x < cellSize; ++x) {\n        // Calculate the maximum height at the x and z position for a voxel to be placed\n        const height =\n          (Math.sin((x / cellSize) * Math.PI * 2) +\n            Math.sin((z / cellSize) * Math.PI * 3)) *\n            (cellSize / 6) +\n          cellSize / 2;\n\n        // Set voxel if y is below the height\n        if (y < height) {\n          // Set voxel to random texture\n          world.setVoxel(\n            startX + x,\n            startY + y,\n            startZ + z,\n            v ? v : randInt(1, 17)\n          );\n        }\n      }\n    }\n  }\n}\n*/\n\n/**\n * Has the cell at the given coordinates form a flat ground out of its voxels.\n * @param {VoxelWorld} world - The world to spawn flat ground in\n * @param {number} cellX\n * @param {number} cellY\n * @param {number} cellZ\n * @param {number} cellSize - Dimensions of the cell\n * @param {number} [v=0] - The type of voxel to spawn. 0 for random\n */\nfunction createFlatGround(world, cellX, cellY, cellZ, cellSize, v = 0) {\n  const startX = cellX * cellSize;\n  const startY = cellY * cellSize;\n  const startZ = cellZ * cellSize;\n\n  // Create flat ground with our voxels\n  for (let z = 0; z < cellSize; ++z) {\n    for (let x = 0; x < cellSize; ++x) {\n      // Set voxel to random texture or v if given\n      world.setVoxel(startX + x, startY, startZ + z, v ? v : randInt(1, 17));\n    }\n  }\n}\n\n/**\n * TODO: Temporary function for creating the texture atlas. Will be removed\n * during the creation of the ColorPalette code.\n * @param {*} render\n * @return texture\n */\n/*\nfunction createTextureAtlas(render) {\n  // Load texture atlas\n  const loader = new THREE.TextureLoader();\n  const texture = loader.load(textureAtlas, render);\n  texture.magFilter = THREE.NearestFilter;\n  texture.minFilter = THREE.NearestFilter;\n  return texture;\n}\n*/\n\n/**\n * Class used to interface with the scene and handles the main render loop.\n */\nclass VoxelEditor {\n  constructor(options) {\n    this.canvas = options.canvas;\n    this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas });\n\n    // Length, width, and height of each cell in the VoxelWorld\n    this.cellSize = 32;\n\n    // Initialize the camera\n    this.createCamera();\n\n    // Initialize orbit controls\n    this.createOrbitControls();\n\n    // Create the scene\n    this.scene = new THREE.Scene();\n\n    // Setting background color to the same one Blender uses\n    this.scene.background = new THREE.Color(\"#3C3C3C\");\n\n    // Add two directional lights to the scene\n    this.addLight(-1, 2, 4);\n    this.addLight(1, -1, -2);\n\n    // TODO: Remove these variables soon. Not needed for ColorPalette\n    const tileSize = 16;\n    const tileTextureWidth = 256;\n    const tileTextureHeight = 64;\n    //const texture = createTextureAtlas(this.render);\n\n    // Create material for the voxel model\n    const material = new THREE.MeshLambertMaterial({\n      // TODO: add texture back if using textures\n      //map: texture,\n      side: THREE.DoubleSide,\n      alphaTest: 0.1,\n      transparent: true,\n      vertexColors: true,\n    });\n\n    // Load from previous world or set defaults\n    const { world } = options;\n    const colorPalette = world ? world.colorPalette : new ColorPalette();\n    const cells = world ? world.cells : {};\n\n    // Create a new VoxelWorld that will manage our voxels\n    this.world = new VoxelWorld({\n      cellSize: this.cellSize,\n      tileSize,\n      tileTextureWidth,\n      tileTextureHeight,\n      material,\n      colorPalette,\n      cells,\n    });\n\n    // If there is no pre-existing world, create flat ground by default\n    if (!world) {\n      // Create a floor to the world\n      createFlatGround(this.world, 0, 0, 0, this.cellSize, 1); // Center\n    }\n\n    // Update geometry of the entire world\n    this.world.updateWorldGeometry(this.scene);\n\n    // Used with requestRenderIfNotRequested() function\n    this.renderRequested = false;\n\n    // Mouse object representing the position of mouse clicks.\n    this.mouse = {\n      x: 0,\n      y: 0,\n      moveX: 0,\n      moveY: 0,\n    };\n\n    // Listen for mouse clicks\n    this.canvas.addEventListener(\n      \"pointerdown\",\n      (event) => {\n        event.preventDefault();\n        // Record where we first clicked\n        this.recordStartPosition(event);\n\n        // Record mouse movement\n        window.addEventListener(\"pointermove\", this.recordMovement);\n\n        // Add voxel upon releasing mouse click if movement is small. Other,\n        // user is orbiting the camera\n        window.addEventListener(\"pointerup\", this.placeVoxelIfNoMovement);\n      },\n      { passive: false }\n    );\n\n    // Listen for touch events\n    this.canvas.addEventListener(\n      \"touchstart\",\n      (event) => {\n        // prevent scrolling\n        event.preventDefault();\n      },\n      { passive: false }\n    );\n\n    // Listen for camera orbit events\n    this.controls.addEventListener(\"change\", this.requestRenderIfNotRequested);\n\n    // Listen for window resizing events\n    window.addEventListener(\"resize\", this.requestRenderIfNotRequested);\n\n    // Create new brush\n    this.brush = new Brush();\n\n    // Start render loop\n    this.render();\n  }\n\n  /**\n   * Helper function used to create the camera and set it to a default position.\n   * @param {number} [fov=75] - field of view\n   * @param {number} [aspect=2] - Aspect. Canvas default is 2\n   * @param {number} [near=0.1]\n   * @param {number} [far=1000]\n   */\n  createCamera(fov = 75, aspect = 2, near = 0.1, far = 1000) {\n    // Create a new perspective camera\n    this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n\n    // TODO: This is an arbitrary starting position. Consider an alternative\n    this.camera.position.set(\n      -this.cellSize * 0.2,\n      this.cellSize * 0.3,\n      -this.cellSize * 0.2\n    );\n  }\n\n  /**\n   * Helper function to create the orbit controls.\n   */\n  createOrbitControls() {\n    // Create the orbit controls\n    this.controls = new OrbitControls(this.camera, this.canvas);\n\n    // Orbit controls starts by targeting center of scene\n    this.controls.target.set(this.cellSize / 2, 0, this.cellSize / 2);\n\n    // Controls must be updated before they can be used\n    this.controls.update();\n  }\n\n  /**\n   * Adds a directional light to the scene at the given x, y, and z position.\n   * Remember, the default position of the directional light's target is (0, 0, 0).\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   */\n  addLight(x, y, z) {\n    const color = 0xffffff;\n    const intensity = 1;\n    const light = new THREE.DirectionalLight(color, intensity);\n    light.position.set(x, y, z);\n    this.scene.add(light);\n  }\n\n  /**\n   * Checks if the renderer needs to resize to account for changes in screen\n   * width or height.\n   * @param {WebGLRenderer} renderer\n   * @returns {boolean} True if the renderer resized. False otherwise.\n   */\n  resizeRendererToDisplaySize(renderer) {\n    const canvas = renderer.domElement;\n\n    const width = canvas.clientWidth;\n    const height = canvas.clientHeight;\n\n    const needResize = canvas.width !== width || canvas.height !== height;\n    if (needResize) {\n      renderer.setSize(width, height, false);\n    }\n    return needResize;\n  }\n\n  /**\n   * Main render loop.\n   */\n  render = () => {\n    this.renderRequested = undefined;\n\n    if (this.resizeRendererToDisplaySize(this.renderer)) {\n      this.camera.aspect = this.canvas.clientWidth / this.canvas.clientHeight;\n      this.camera.updateProjectionMatrix();\n    }\n\n    this.controls.update();\n    this.renderer.render(this.scene, this.camera);\n  };\n\n  /**\n   * Used to make a render update request only if one hasn't been made already.\n   */\n  requestRenderIfNotRequested = () => {\n    if (!this.renderRequested) {\n      this.renderRequested = true;\n      requestAnimationFrame(this.render);\n    }\n  };\n\n  /**\n   * Finds the x and y coordinate of a mouse click relative to the canvas.\n   * @param {Event} event\n   * @returns {Object} Object with x and y coordinates of click relative to canvas\n   */\n  getCanvasRelativePosition(event) {\n    const { canvas } = this;\n    const rect = canvas.getBoundingClientRect();\n\n    // Calculate the x and y of click relative to the canvas\n    return {\n      x: ((event.clientX - rect.left) * canvas.width) / rect.width,\n      y: ((event.clientY - rect.top) * canvas.height) / rect.height,\n    };\n  }\n\n  /**\n   * Handler for adding, removing, or painting a voxel based on the given brush\n   * and where the user clicked.\n   * @param {Event} event\n   */\n  placeVoxel(event) {\n    // Find position of mouse click relative to canvas\n    const pos = this.getCanvasRelativePosition(event);\n    const x = (pos.x / this.canvas.width) * 2 - 1;\n    const y = (pos.y / this.canvas.height) * -2 + 1; // note we flip Y\n\n    // Get the starting and ending vectors for our raycast\n    const start = new THREE.Vector3();\n    const end = new THREE.Vector3();\n    start.setFromMatrixPosition(this.camera.matrixWorld);\n    end.set(x, y, 1).unproject(this.camera);\n\n    // Cast a ray into the scene\n    const intersection = this.world.intersectRay(start, end);\n\n    // If raycast was successful, place a voxel with the information returned\n    if (intersection) {\n      // Set voxelId depending on brush option. 0 removes voxels\n      const voxelId =\n        this.brush.currentBrush === Brush.brushOptions.remove\n          ? 0\n          : this.world.colorPalette.getSelectedColorIndex() + 1;\n\n      // the intersection point is on the face. That means\n      // the math imprecision could put us on either side of the face.\n      // so go half a normal into the voxel if removing/painting\n      // or half a normal out if adding\n      const pos = intersection.position.map((v, ndx) => {\n        return (\n          v +\n          intersection.normal[ndx] *\n            (this.brush.currentBrush === Brush.brushOptions.add ? 0.5 : -0.5)\n        );\n      });\n\n      // Set voxel at the pos position with new voxelID\n      this.world.setVoxel(...pos, voxelId);\n\n      // Update the cell associated with the position of the new voxel\n      this.world.updateVoxelGeometry(this.scene, ...pos);\n\n      // Update render frame\n      this.requestRenderIfNotRequested();\n    }\n  }\n\n  /**\n   * Reset mouse movement and begin recording.\n   * @param {Event} event\n   */\n  recordStartPosition = (event) => {\n    const { mouse } = this;\n    mouse.x = event.clientX;\n    mouse.y = event.clientY;\n    mouse.moveX = 0;\n    mouse.moveY = 0;\n  };\n\n  /**\n   * Callback function used to record how far the mouse has moved since started recording.\n   * @param {Event} event\n   */\n  recordMovement = (event) => {\n    const { mouse } = this;\n    mouse.moveX += Math.abs(mouse.x - event.clientX);\n    mouse.moveY += Math.abs(mouse.y - event.clientY);\n  };\n\n  /**\n   * Callback function used to check if the user meant to set a voxel instead\n   * of orbiting the camera.\n   * @param {Event} event\n   */\n  placeVoxelIfNoMovement = (event) => {\n    const { mouse } = this;\n    // Mouse hardly moved, user likely intended to place a voxel\n    if (mouse.moveX < 5 && mouse.moveY < 5) {\n      // TODO: Remove global variable currentBrush\n      this.placeVoxel(event);\n    }\n\n    // Stop recording movement and checks to place voxel\n    window.removeEventListener(\"pointermove\", this.recordMovement);\n    window.removeEventListener(\"pointerup\", this.placeVoxelIfNoMovement);\n  };\n\n  /**\n   * Called whenever a new color is selected.\n   * @param {number} index - Index of the changed color\n   * @param {r} r - Red color from 0-1\n   * @param {g} g - Green color from 0-1\n   * @param {b} b - Blue color from 0-1\n   */\n  onSelectedColorChange = (index, r, g, b) => {\n    // Update the color\n    this.world.colorPalette.setColorAtIndex(index, r, g, b);\n\n    // Updated the world with new color\n    this.world.updateWorldGeometry(this.scene);\n\n    // Update render frame\n    this.requestRenderIfNotRequested();\n  };\n\n  /**\n   * Updates which voxel the user is placing/painting now from the palette.\n   * @param {number} index\n   */\n  onNewSelectedColor = (index) => {\n    // Update the currently selected color for adding/painting\n    this.world.colorPalette.setSelectedColor(index);\n  };\n}\n\nexport default VoxelEditor;\n","import React from \"react\";\nimport GUIController from \"./GUIController\";\nimport VoxelEditor from \"../modules/VoxelsEditor\";\n\n/**\n * The main driving component for the application. Sets up the rest of\n * the user interface and directly communicates with the Voxel.js module.\n * @extends React.Component\n */\nclass VoxelManager extends React.Component {\n  constructor(props) {\n    super(props);\n\n    // The VoxelEditor itself that handles the 3D scene\n    this.voxelEditor = null;\n  }\n\n  /**\n   * Takes the given canvas Ref and renders the voxel world.\n   * @param {Ref} canvasRef\n   */\n  createVoxelWorld = (canvasRef) => {\n    if (!canvasRef) return;\n\n    if (!this.voxelEditor) {\n      this.voxelEditor = new VoxelEditor({ canvas: canvasRef.current });\n    } else {\n      const world = this.voxelEditor.world;\n      this.voxelEditor = new VoxelEditor({ canvas: canvasRef.current, world });\n    }\n  };\n\n  /**\n   * Changes the brush currently being used.\n   * @param {string} brushName - name of the brush to set\n   */\n  setCurrentBrush = (brushName) => {\n    if (this.voxelEditor) {\n      this.voxelEditor.brush.setCurrentBrush(brushName);\n    }\n  };\n\n  /**\n   * Returns color palette data from the VoxelWorld.\n   * @returns {Array.Color}\n   */\n  onGetColorData = () => {\n    // Return empty array if voxelEditor not ready\n    // TODO: Redo this.\n    if (!this.voxelEditor) {\n      return {\n        colors: [],\n        selectedColorIndex: 0,\n        currentColor: { r: 127.5, g: 127.5, b: 127.5 }, // default to a grey color\n        isColorsFull: true,\n      };\n    }\n\n    const { colorPalette } = this.voxelEditor.world;\n    const { r, g, b } = colorPalette.getSelectedColor().getRGB255();\n    return {\n      colors: colorPalette.getColorsArray(),\n      selectedColorIndex: colorPalette.getSelectedColorIndex(),\n      currentColor: { r, g, b },\n      isColorsFull: colorPalette.isColorsFull(),\n    };\n  };\n\n  /**\n   * Called whenever a new color is selected.\n   * @param {number} index - Index of the changed color\n   * @param {Object} color\n   */\n  onSelectedColorChange = (index, color) => {\n    if (this.voxelEditor) {\n      const { r, g, b } = color;\n\n      // Adjust the color to be on a 0-1 range\n      this.voxelEditor.onSelectedColorChange(index, r / 255, g / 255, b / 255);\n    }\n  };\n\n  /**\n   * Tells the VoxelEditor what color of voxel the user is placing/painting now.\n   * @param {number} index\n   */\n  onNewSelectedColor = (index) => {\n    if (this.voxelEditor) {\n      this.voxelEditor.onNewSelectedColor(index);\n    }\n  };\n\n  /**\n   * Tell the VoxelEditor that the user added a new color to their color palette\n   */\n  onAddColor = () => {\n    if (!this.voxelEditor) return;\n\n    // Add a new color to the color palette\n    this.voxelEditor.world.colorPalette.addColor();\n  };\n\n  render() {\n    return (\n      <GUIController\n        onCanvasCreation={this.createVoxelWorld}\n        onBrushChange={this.setCurrentBrush}\n        onGetColorData={this.onGetColorData}\n        onSelectedColorChange={this.onSelectedColorChange}\n        onNewSelectedColor={this.onNewSelectedColor}\n        onAddColor={this.onAddColor}\n      />\n    );\n  }\n}\n\nexport default VoxelManager;\n","import \"./App.css\";\nimport VoxelManager from \"./VoxelManager\";\n\nconst App = () => {\n  return <VoxelManager />;\n};\n\nexport default App;\n","import \"semantic-ui-css/semantic.min.css\";\nimport \"./ColorVariables.css\";\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./components/App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}